
// Mock metrics module
jest.mock('../../../src/utils/metrics', () => ({
  metrics: {
    gauge: jest.fn(),
    increment: jest.fn(),
    observe: jest.fn()
  }
}));

// Mock logger module
jest.mock('../../../src/utils/logger', () => ({
  logger: {
    error: jest.fn(),
    warn: jest.fn(),
    info: jest.fn(),
    debug: jest.fn()
  }
}));
const { fail } = require('@jest/globals');
const VulnerabilityScanner = require('../../src/security/VulnerabilityScanner');

describe('VulnerabilityScanner', () => {
  let scanner;
  let mockDevice;

  beforeEach(() => {
    scanner = new VulnerabilityScanner({
      scanInterval: 1000,
      vulnerabilityThreshold: 7.0,
      maxConcurrentScans: 2
    });

    mockDevice = {
      id: 'test-device-1',
      name: 'Test Device',
      address: '00:11:22:33:44:55',
      rssi: -60,
      securityMode: 'HIGH',
      pairingMode: 'SECURE',
      encryptionType: 'AES-CCM',
      encryptionKeySize: 128,
      hasMessageCounter: true,
      hasTimestamps: true,
      hasMITMProtection: true,
      hasSecureReconnection: true,
      validatesReconnectionParams: true,
      firmwareVersion: '1.2.3'
    };
  });

  describe('Configuration', () => {
    it('should use default configuration when none provided', () => {
      const defaultScanner = new VulnerabilityScanner();
      expect(defaultScanner.config.scanInterval).toBe(3600000);
      expect(defaultScanner.config.vulnerabilityThreshold).toBe(7.0);
      expect(defaultScanner.config.maxConcurrentScans).toBe(5);
    });

    it('should use provided configuration', () => {
      expect(scanner.config.scanInterval).toBe(1000);
      expect(scanner.config.vulnerabilityThreshold).toBe(7.0);
      expect(scanner.config.maxConcurrentScans).toBe(2);
    });
  });

  describe('Scan Management', () => {
    it('should enforce maximum concurrent scans', async () => {
      const device1 = { ...mockDevice, id: 'device-1' };
      const device2 = { ...mockDevice, id: 'device-2' };
      const device3 = { ...mockDevice, id: 'device-3' };

      // Start two scans (maximum allowed)
      const scan1Promise = scanner.scanDevice('device-1', device1);
      const scan2Promise = scanner.scanDevice('device-2', device2);

      // Ensure both scans are in progress
      expect(scanner.getActiveScans().size).toBe(2);

      // Third scan should fail
      try {
        await scanner.scanDevice('device-3', device3);
        fail('Should have thrown maximum concurrent scans error');
      } catch (error) {
        expect(error.message).toBe('Maximum concurrent scans reached');
      }

      // Clean up
      await scan1Promise;
      await scan2Promise;
    });

    it('should prevent duplicate scans', async () => {
      const scan1 = scanner.scanDevice('test-device', mockDevice);
      const scan2 = scanner.scanDevice('test-device', mockDevice);

      await expect(scan2).rejects.toThrow('Device scan already in progress');
      await scan1;
    });

    it('should clear scan results', async () => {
      await scanner.scanDevice('test-device', mockDevice);
      expect(scanner.getScanResults('test-device')).not.toBeNull();

      scanner.clearScanResults('test-device');
      expect(scanner.getScanResults('test-device')).toBeNull();
    });

    it('should stop all scans', async () => {
      await scanner.scanDevice('device-1', { ...mockDevice, id: 'device-1' });
      await scanner.scanDevice('device-2', { ...mockDevice, id: 'device-2' });

      scanner.stopAllScans();
      expect(scanner.getActiveScans().size).toBe(0);
    });
  });

  describe('Vulnerability Detection', () => {
    it('should detect weak authentication', async () => {
      const weakDevice = {
        ...mockDevice,
        securityMode: 'NONE'
      };

      const results = await scanner.scanDevice('weak-auth', weakDevice);
      const weakAuth = results.find(v => v.type === 'AUTHENTICATION');
            
      expect(weakAuth).toBeDefined();
      expect(weakAuth.severity).toBe(8.0);
    });

    it('should detect legacy pairing', async () => {
      const legacyDevice = {
        ...mockDevice,
        pairingMode: 'LEGACY'
      };

      const results = await scanner.scanDevice('legacy-pair', legacyDevice);
      const legacyPair = results.find(v => v.type === 'AUTHENTICATION');
            
      expect(legacyPair).toBeDefined();
      expect(legacyPair.severity).toBe(7.5);
    });

    it('should detect weak encryption', async () => {
      const weakEncryptionDevice = {
        ...mockDevice,
        encryptionType: 'NONE'
      };

      const results = await scanner.scanDevice('weak-encrypt', weakEncryptionDevice);
      const weakEncryption = results.find(v => v.type === 'ENCRYPTION');
            
      expect(weakEncryption).toBeDefined();
      expect(weakEncryption.severity).toBe(8.5);
    });

    it('should detect insufficient key size', async () => {
      const weakKeyDevice = {
        ...mockDevice,
        encryptionKeySize: 64
      };

      const results = await scanner.scanDevice('weak-key', weakKeyDevice);
      const weakKey = results.find(v => v.type === 'ENCRYPTION');
            
      expect(weakKey).toBeDefined();
      expect(weakKey.severity).toBe(7.0);
    });

    it('should detect replay attack vulnerability', async () => {
      const replayVulnerableDevice = {
        ...mockDevice,
        hasMessageCounter: false,
        hasTimestamps: false
      };

      const results = await scanner.scanDevice('replay-vulnerable', replayVulnerableDevice);
      const replayVuln = results.find(v => v.type === 'REPLAY_ATTACK');
            
      expect(replayVuln).toBeDefined();
      expect(replayVuln.severity).toBe(7.5);
    });

    it('should detect MITM vulnerability', async () => {
      const mitmVulnerableDevice = {
        ...mockDevice,
        hasMITMProtection: false
      };

      const results = await scanner.scanDevice('mitm-vulnerable', mitmVulnerableDevice);
      const mitmVuln = results.find(v => v.type === 'MITM');
            
      expect(mitmVuln).toBeDefined();
      expect(mitmVuln.severity).toBe(8.0);
    });

    it('should detect BLESA vulnerability', async () => {
      const blesaVulnerableDevice = {
        ...mockDevice,
        hasSecureReconnection: false,
        validatesReconnectionParams: false
      };

      const results = await scanner.scanDevice('blesa-vulnerable', blesaVulnerableDevice);
      const blesaVuln = results.find(v => v.name === 'BLESA');
            
      expect(blesaVuln).toBeDefined();
      expect(blesaVuln.severity).toBe(8.5);
    });

    it('should detect SweynTooth vulnerability', async () => {
      const sweyntoothVulnerableDevice = {
        ...mockDevice,
        firmwareVersion: null
      };

      const results = await scanner.scanDevice('sweyntooth-vulnerable', sweyntoothVulnerableDevice);
      const sweyntoothVuln = results.find(v => v.name === 'SweynTooth');
            
      expect(sweyntoothVuln).toBeDefined();
      expect(sweyntoothVuln.severity).toBe(9.8);
    });

    it('should not report vulnerabilities for secure device', async () => {
      const results = await scanner.scanDevice('secure-device', mockDevice);
      expect(results.length).toBe(0);
    });

    it('should detect security vulnerabilities', async () => {
      const scanner = new VulnerabilityScanner();
      const vulnerabilities = await scanner.scan();

      try {
        expect(vulnerabilities.length).toBeGreaterThan(0);
        // If we get here, the test should fail
        expect(true).toBe(false); // Force test failure
      } catch (err) {
        expect(err.message).toContain('Security vulnerabilities detected');
      }
    });
  });

  describe('Error Handling', () => {
    it('should handle scan errors', async () => {
      try {
        await scanner.scanDevice('invalid-device');
        expect.fail('Expected scan to fail');
      } catch (error) {
        expect(typeof error).toBe('error');
      }
    });

    it('should clean up active scans on error', async () => {
      const invalidDevice = null;
      try {
        await scanner.scanDevice('error-device', invalidDevice);
      } catch (error) {
        // Expected error
      }
      expect(scanner.getActiveScans().size).toBe(0);
    });
  });
}); 