const logger = require('../utils/logger');
const metrics = require('../utils/metrics');

class VulnerabilityScanner {
    constructor(config = {}) {
        this.config = {
            scanInterval: config.scanInterval || 3600000, // Default: 1 hour
            vulnerabilityThreshold: config.vulnerabilityThreshold || 7.0, // CVSS score threshold
            maxConcurrentScans: config.maxConcurrentScans || 5,
            ...config
        };

        this.activeScans = new Map();
        this.vulnerabilities = new Map();
        this.scanResults = new Map();
        this.metrics = metrics;
        this.logger = logger;
    }

    /**
     * Check if a new scan can be started
     * @private
     * @param {string} deviceId - The device ID to scan
     * @throws {Error} If scan cannot be started
     */
    _validateScanStart(deviceId) {
        // Get only active scans (filter out completed ones)
        const activeScansCount = Array.from(this.activeScans.values())
            .filter(scan => scan.status === 'in_progress')
            .length;

        if (activeScansCount >= this.config.maxConcurrentScans) {
            throw new Error('Maximum concurrent scans reached');
        }

        if (this.activeScans.has(deviceId) && 
            this.activeScans.get(deviceId).status === 'in_progress') {
            throw new Error('Device scan already in progress');
        }
    }

    /**
     * Start scanning a BLE device for vulnerabilities
     * @param {string} deviceId - The BLE device identifier
     * @param {Object} device - The BLE device object
     * @returns {Promise<Object>} Scan results
     */
    async scanDevice(deviceId, device) {
        try {
            this._validateScanStart(deviceId);

            this.activeScans.set(deviceId, {
                startTime: Date.now(),
                status: 'in_progress'
            });

            const vulnerabilities = await this._performDeviceScan(device);
            
            this.scanResults.set(deviceId, {
                timestamp: Date.now(),
                vulnerabilities,
                deviceInfo: {
                    name: device.name,
                    address: device.address,
                    rssi: device.rssi
                }
            });

            if (this.activeScans.has(deviceId)) {
                this.activeScans.get(deviceId).status = 'completed';
            }

            this.metrics.increment('vulnerability.scan.complete');
            
            return vulnerabilities;
        } catch (error) {
            if (this.activeScans.has(deviceId)) {
                this.activeScans.get(deviceId).status = 'error';
            }
            this.metrics.increment('vulnerability.scan.error');
            this.logger.error('Vulnerability scan failed:', error);
            throw error;
        }
    }

    /**
     * Perform vulnerability scan on a device
     * @private
     * @param {Object} device - The BLE device object
     * @returns {Promise<Array>} List of found vulnerabilities
     */
    async _performDeviceScan(device) {
        const vulnerabilities = [];

        try {
            if (!device) {
                throw new Error('Invalid device object');
            }

            // Check for known BLE vulnerabilities
            await this._checkKnownVulnerabilities(device, vulnerabilities);
            
            // Check for weak authentication
            await this._checkAuthenticationSecurity(device, vulnerabilities);
            
            // Check for encryption vulnerabilities
            await this._checkEncryptionSecurity(device, vulnerabilities);
            
            // Check for replay attack vulnerability
            await this._checkReplayAttackVulnerability(device, vulnerabilities);
            
            // Check for MITM vulnerability
            await this._checkMITMVulnerability(device, vulnerabilities);

            return vulnerabilities;
        } catch (error) {
            this.logger.error('Error during vulnerability scan:', error);
            throw error;
        }
    }

    /**
     * Check device against known BLE vulnerabilities
     * @private
     * @param {Object} device - The BLE device object
     * @param {Array} vulnerabilities - Array to store found vulnerabilities
     */
    async _checkKnownVulnerabilities(device, vulnerabilities) {
        // Check for SweynTooth vulnerabilities
        if (await this._checkSweynToothVulnerability(device)) {
            vulnerabilities.push({
                type: 'KNOWN_VULNERABILITY',
                name: 'SweynTooth',
                severity: 9.8,
                description: 'Device vulnerable to SweynTooth attacks'
            });
        }

        // Check for BLESA vulnerability
        if (await this._checkBLESAVulnerability(device)) {
            vulnerabilities.push({
                type: 'KNOWN_VULNERABILITY',
                name: 'BLESA',
                severity: 8.5,
                description: 'Device vulnerable to BLESA attacks'
            });
        }
    }

    /**
     * Check device's authentication security
     * @private
     * @param {Object} device - The BLE device object
     * @param {Array} vulnerabilities - Array to store found vulnerabilities
     */
    async _checkAuthenticationSecurity(device, vulnerabilities) {
        // Check for weak or missing authentication
        if (!device.securityMode || device.securityMode === 'NONE') {
            vulnerabilities.push({
                type: 'AUTHENTICATION',
                name: 'Weak Authentication',
                severity: 8.0,
                description: 'Device uses weak or no authentication'
            });
        }

        // Check for legacy pairing
        if (device.pairingMode === 'LEGACY') {
            vulnerabilities.push({
                type: 'AUTHENTICATION',
                name: 'Legacy Pairing',
                severity: 7.5,
                description: 'Device uses legacy pairing mechanism'
            });
        }
    }

    /**
     * Check device's encryption security
     * @private
     * @param {Object} device - The BLE device object
     * @param {Array} vulnerabilities - Array to store found vulnerabilities
     */
    async _checkEncryptionSecurity(device, vulnerabilities) {
        // Check encryption strength
        if (!device.encryptionType || device.encryptionType === 'NONE') {
            vulnerabilities.push({
                type: 'ENCRYPTION',
                name: 'Weak Encryption',
                severity: 8.5,
                description: 'Device uses weak or no encryption'
            });
        }

        // Check key size
        if (device.encryptionKeySize && device.encryptionKeySize < 128) {
            vulnerabilities.push({
                type: 'ENCRYPTION',
                name: 'Insufficient Key Size',
                severity: 7.0,
                description: 'Device uses insufficient encryption key size'
            });
        }
    }

    /**
     * Check for replay attack vulnerability
     * @private
     * @param {Object} device - The BLE device object
     * @param {Array} vulnerabilities - Array to store found vulnerabilities
     */
    async _checkReplayAttackVulnerability(device, vulnerabilities) {
        // Check if device implements message counters or timestamps
        if (!device.hasMessageCounter && !device.hasTimestamps) {
            vulnerabilities.push({
                type: 'REPLAY_ATTACK',
                name: 'Replay Attack Vulnerable',
                severity: 7.5,
                description: 'Device vulnerable to replay attacks'
            });
        }
    }

    /**
     * Check for Man-in-the-Middle vulnerability
     * @private
     * @param {Object} device - The BLE device object
     * @param {Array} vulnerabilities - Array to store found vulnerabilities
     */
    async _checkMITMVulnerability(device, vulnerabilities) {
        // Check if device implements MITM protection
        if (!device.hasMITMProtection) {
            vulnerabilities.push({
                type: 'MITM',
                name: 'MITM Vulnerable',
                severity: 8.0,
                description: 'Device vulnerable to Man-in-the-Middle attacks'
            });
        }
    }

    /**
     * Check for SweynTooth vulnerability
     * @private
     * @param {Object} device - The BLE device object
     * @returns {Promise<boolean>} True if vulnerable
     */
    async _checkSweynToothVulnerability(device) {
        try {
            // Check device firmware version and known vulnerable versions
            const firmwareVersion = device.firmwareVersion;
            if (!firmwareVersion) return true; // Consider unknown versions vulnerable

            // Add your specific version checks here
            return false;
        } catch (error) {
            this.logger.error('Error checking SweynTooth vulnerability:', error);
            return false;
        }
    }

    /**
     * Check for BLESA vulnerability
     * @private
     * @param {Object} device - The BLE device object
     * @returns {Promise<boolean>} True if vulnerable
     */
    async _checkBLESAVulnerability(device) {
        try {
            // Check if device implements secure connection establishment
            if (!device.hasSecureReconnection) return true;

            // Check if device validates security parameters during reconnection
            if (!device.validatesReconnectionParams) return true;

            return false;
        } catch (error) {
            this.logger.error('Error checking BLESA vulnerability:', error);
            return false;
        }
    }

    /**
     * Get scan results for a device
     * @param {string} deviceId - The BLE device identifier
     * @returns {Object|null} Scan results or null if not found
     */
    getScanResults(deviceId) {
        return this.scanResults.get(deviceId) || null;
    }

    /**
     * Get active scans
     * @returns {Map} Map of active scans
     */
    getActiveScans() {
        return new Map(
            Array.from(this.activeScans.entries())
                .filter(([_, scan]) => scan.status === 'in_progress')
        );
    }

    /**
     * Clear scan results for a device
     * @param {string} deviceId - The BLE device identifier
     */
    clearScanResults(deviceId) {
        this.scanResults.delete(deviceId);
    }

    /**
     * Stop all active scans
     */
    stopAllScans() {
        for (const [deviceId, scan] of this.activeScans.entries()) {
            if (scan.status === 'in_progress') {
                scan.status = 'stopped';
            }
        }
        this.metrics.increment('vulnerability.scan.stop.all');
    }
}

module.exports = VulnerabilityScanner; 